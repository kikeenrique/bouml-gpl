class UmlClass
!!!128480.cpp!!!	sKind() : string
  return "class";
!!!128480.java!!!	sKind() : string
  return "class";
!!!128129.cpp!!!	memo_ref() : void
  classes.addElement(this);
  UmlItem::memo_ref();
  
  const QVector<UmlItem> ch = children();
  
  if (inherited_opers == 0)
    add_inherited_opers(0);
	
  for (unsigned i = 0; i != ch.size(); i += 1) {
    if (ch[i]->kind() == aRelation) {
      UmlRelation * rel = (UmlRelation *) ch[i];
      aRelationKind k = rel->relationKind();
      
      if ((k == aGeneralisation) || (k == aRealization))
	rel->roleType()->subClasses.addElement(this);
    }
  }

  unload(TRUE, FALSE);
!!!128129.java!!!	memo_ref() : void
  classes.addElement(this);
  super.memo_ref();
  
  UmlItem[] ch = children();
  
  if (inherited_opers == null)
    add_inherited_opers(null);
	
  for (int i = 0; i != ch.length; i += 1) {
    if (ch[i].kind() == anItemKind.aRelation) {
      UmlRelation rel = (UmlRelation) ch[i];
      aRelationKind k = rel.relationKind();
      
      if ((k == aRelationKind.aGeneralisation) ||
	  (k == aRelationKind.aRealization))
	rel.roleType().subClasses.addElement(this);
    }
  }

  unload(true, false);
!!!128499.cpp!!!	html(in pfix : string, in rank : uint, in level : uint) : void
  if (flat) {
    define();
    chapter("Class", pfix, rank, "class", level);
    gen_html(pfix, rank, level);
    unload(FALSE, FALSE);
  }
  else {
    fw.write("<table><tr><td><div class=\"element\">Class <b>");
    write();
    fw.write("</b></div></td></tr></table>\n");
  }
!!!128499.java!!!	html(in pfix : string, in rank : uint, in level : uint) : void
  if (flat) {
    define();
    chapter("Class", pfix, rank, "class", level);
    gen_html(pfix, rank, level);
    unload(false, false);
  }
  else {
    fw.write("<table><tr><td><div class=\"element\">Class <b>");
    write();
    fw.write("</b></div></td></tr></table>\n");
  }
!!!130675.cpp!!!	html() : void
  QCString s;
  
  UmlCom::message(name());
  
  start_file("class" + s.setNum(refId), "Class " + name(), TRUE);
  define();
  gen_html("", 0, 0);
  end_file();
  
  unload(FALSE, FALSE);
!!!130675.java!!!	html() : void
  String s;
  
  UmlCom.message(name());
  
  start_file("class" + String.valueOf(refId), "Class " + name(), true);
  define();
  gen_html(null, 0, 0);
  end_file();

  unload(false, false);
!!!150146.cpp!!!	gen_html(in pfix : string, in rank : uint, in level : uint) : void
  UmlCom::message(name());
  
  QCString s;
  
  fw.write("<p>Declaration :</p><ul>");
  
  s = cppDecl();

  if (!s.isEmpty()) {
    fw.write("<li>C++ : ");
    gen_cpp_decl(s, FALSE);
    fw.write("</li>");
  }

  s = javaDecl();

  if (!s.isEmpty()) {
    fw.write("<li>Java : ");
    gen_java_decl(s);
    fw.write("</li>");
  }

  fw.write("</ul>");
  
  if (subClasses.size() != 0) {
    sort(subClasses);
    fw.write("<p>Directly inherited by : ");
    
    for (unsigned i = 0; i != subClasses.size(); i += 1) {
      subClasses.elementAt(i)->write();
      fw.write(' ');
    }
    fw.write("</p>\n");    
  }
  
  write_dependencies();

  annotation();
 
  s = description();
  
  if (!s.isEmpty()) {
    fw.write("<p>");
    gen_cpp_decl(s, TRUE);
    fw.write("<br /></p>");
  }
  
  bool p = FALSE;
  UmlItem * x;
  
  if ((x = associatedArtifact()) != 0) {
    p = TRUE;
    fw.write("<p>Artifact : ");
    x->write();
  }

  const QVector<UmlComponent> comps = associatedComponents();
  
  if (comps.size() != 0) {
    if (p) 
      fw.write(", Component(s) :");
    else {
      p = TRUE;
      fw.write("<p>Component(s) :");
    }
    
    for (unsigned i = 0; i != comps.size(); i += 1) {
      fw.write(' ');
      comps[i]->write();
    }
  }

  if ((x = associatedDiagram()) != 0) {
    if (p) 
      fw.write(", Diagram : ");
    else {
      p = TRUE;
      fw.write("<p>Diagram : ");
    }
    x->write();
  }

  if (p)
    fw.write("</p>");
  
  if (parent()->kind() == aClass) {
    fw.write("<p>nested in ");
    parent()->write();
    fw.write("</p>\n");
  }

  //

  const QVector<UmlItem> ch = children();
  
  if (ch.size() != 0) {
    fw.write("<div class=\"sub\">\n");
    
    if (stereotype() == "enum_pattern") {

      fw.write("<p>Items :</p><ul>\n");
      
      for (unsigned i = 0; i != ch.size(); i += 1) {
	if (ch[i]->kind() == anAttribute) {
	  fw.write("<li>");
	  writeq(ch[i]->name());
	  fw.write("</li>\n");
	}
      }
      
      fw.write("</ul>\n");
    }
    else if (stereotype() == "enum") {
      unsigned i;

      fw.write("<p>Items :</p><ul>\n");
      
      for (i = 0; i != ch.size(); i += 1) {
	if ((ch[i]->kind() == anAttribute) &&
	    (ch[i]->stereotype() != "attribute")) {
	  fw.write("<li>");
	  writeq(ch[i]->name());
	  fw.write("</li>\n");
	}
      }
      
      fw.write("</ul>\n");
      
      s = "";
      for (i = 0; i != ch.size(); i += 1)
	if ((ch[i]->kind() != anAttribute) ||
	    (ch[i]->stereotype() == "attribute"))
	  ch[i]->html(s, 0, 0);
    }
    else if (flat)
      write_children(pfix, rank, level);
    else {
      // non flat
      s = "";
      for (unsigned i = 0; i != ch.size(); i += 1)
	ch[i]->html(s, 0, 0);
    }
    
    fw.write("</div>\n");
  }

  sort(*inherited_opers);
  bool already = FALSE;
  
  for (unsigned i = 0; i != inherited_opers->size(); i += 1) {
    if (already)
      fw.write(", ");
    else {
      already = TRUE;
      fw.write("<p>All public operations : ");
    }
    inherited_opers->elementAt(i)->write();
    fw.write(' ');
  }
  if (already)
    fw.write("</p>\n");
!!!150146.java!!!	gen_html(in pfix : string, in rank : uint, in level : uint) : void
  UmlCom.message(name());
  
  String s;
  
  fw.write("<p>Declaration :</p><ul>");
  
  s = cppDecl();

  if (s.length() != 0) {
    fw.write("<li>C++ : ");
    gen_cpp_decl(s, false);
    fw.write("</li>");
  }

  s = javaDecl();

  if (s.length() != 0) {
    fw.write("<li>Java : ");
    gen_java_decl(s);
    fw.write("</li>");
  }

  fw.write("</ul>");
  
  if (subClasses.size() != 0) {
    sort(subClasses);
    fw.write("<p>Directly inherited by : ");
    
    for (int i = 0; i != subClasses.size(); i += 1) {
      ((UmlItem) subClasses.elementAt(i)).write();
      fw.write(' ');
    }
    fw.write("</p>\n");    
  }
  
  write_dependencies();
  
  annotation();
 
  s = description();
  
  if (s.length() != 0) {
    fw.write("<p>");
    gen_cpp_decl(s, true);
    fw.write("<br /></p>");
  }
  
  boolean p = false;
  UmlItem x;
  
  if ((x = associatedArtifact()) != null) {
    p = true;
    fw.write("<p>Artifact : ");
    x.write();
  }

  UmlComponent[] comps = associatedComponents();
  
  if (comps.length != 0) {
    if (p) 
      fw.write(", Component(s) :");
    else {
      p = true;
      fw.write("<p>Component(s) :");
    }
    
    for (int i = 0; i != comps.length; i += 1) {
      fw.write(' ');
      ((UmlItem) comps[i]).write();
    }
  }

  if ((x = associatedDiagram()) != null) {
    if (p) 
      fw.write(", Diagram : ");
    else {
      p = true;
      fw.write("<p>Diagram : ");
    }
    x.write();
  }

  if (p)
    fw.write("</p>");

  if (parent().kind() == anItemKind.aClass) {
    fw.write("<p>nested in ");
    parent().write();
    fw.write("</p>\n");
  }
  
  //

  UmlItem[] ch = children();
  
  if (ch.length != 0) {
    fw.write("<div class=\"sub\">\n");
    
    if (stereotype().equals("enum_pattern")) {
      fw.write("<p>Items :</p><ul>\n");
      
      for (int i = 0; i != ch.length; i += 1) {
	if (ch[i].kind() == anItemKind.anAttribute) {
	  fw.write("<li>");
	  writeq(ch[i].name());
	  fw.write("</li>\n");
	}
      }
      
      fw.write("</ul>\n");
    }
    else if (stereotype().equals("enum")) {
      int i;

      fw.write("<p>Items :</p><ul>\n");
      
      for (i = 0; i != ch.length; i += 1) {
	if ((ch[i].kind() == anItemKind.anAttribute) &&
	    !ch[i].stereotype().equals("attribute")) {
	  fw.write("<li>");
	  writeq(ch[i].name());
	  fw.write("</li>\n");
	}
      }
      
      fw.write("</ul>\n");
      
      s = "";
      
      for (i = 0; i != ch.length; i += 1)
	if ((ch[i].kind() != anItemKind.anAttribute) ||
	    ch[i].stereotype().equals("attribute"))
	  ch[i].html(s, 0, 0);
    }
    else if (flat)
      write_children(pfix, rank, level);
    else {
      // non flat
      s = "";
      
      for (int i = 0; i != ch.length; i += 1)
	ch[i].html(s, 0, 0);
    }
    
    fw.write("</div>\n");
  }

  sort(inherited_opers);
  boolean already = false;
  
  for (int i = 0; i != inherited_opers.size(); i += 1) {
    if (already)
      fw.write(", ");
    else {
      already = true;
      fw.write("<p>All public operations : ");
    }
    ((UmlItem) inherited_opers.elementAt(i)).write();
  }
  if (already)
    fw.write("</p>\n");
!!!130931.cpp!!!	write() : void
  if (refId == 0)
    writeq(name());
  else {
    if (flat)
      fw.write("<a href=\"index");
    else {
      fw.write("<a href=\"class");
      fw.write(refId);
    }
    fw.write(".html#ref");
    fw.write(refId);
    fw.write("\"><b>");
    writeq(name());
    fw.write("</b></a>");
  }
!!!130931.java!!!	write() : void
  if (refId == 0)
    writeq(name());
  else {
    if (flat)
      fw.write("<a href=\"index");
    else {
      fw.write("<a href=\"class");
      fw.write(String.valueOf(refId));
    }
    fw.write(".html#ref");
    fw.write(String.valueOf(refId));
    fw.write("\"><b>");
    writeq(name());
    fw.write("</b></a>");
  }
!!!131059.cpp!!!	write(in target : string) : void
  if (refId != 0) {
    if (flat)
      fw.write("<a href=\"index");
    else {
      fw.write("<a href=\"class");
      fw.write(refId);
    }
    fw.write(".html#ref");
    fw.write(refId);
    fw.write("\" target = \"");
    fw.write(target);
    fw.write("\"><b>");
    writeq(name());
    fw.write("</b></a>");
  }
  else
    writeq(name());
!!!131059.java!!!	write(in target : string) : void
  if (refId != 0) {
    if (flat)
      fw.write("<a href=\"index");
    else {
      fw.write("<a href=\"class");
      fw.write(String.valueOf(refId));
    }
    fw.write(".html#ref");
    fw.write(String.valueOf(refId));
    fw.write("\" target = \"");
    fw.write(target);
    fw.write("\"><b>");
    writeq(name());
    fw.write("</b></a>");
  }
  else
    writeq(name());
!!!128624.cpp!!!	ref_index() : void
  if (!classes.isEmpty())
    fw.write("<a href=\"classes.html\" target = \"projectFrame\"><b> -Classes- </b></a>");
!!!128624.java!!!	ref_index() : void
  if (!classes.isEmpty())
    fw.write("<a href=\"classes.html\" target = \"projectFrame\"><b> -Classes- </b></a>");
!!!128252.cpp!!!	generate_index() : void
  UmlItem::generate_index(classes, "Classes", "classes");

  int n = classes.size();
  
  start_file("classes_list", "Classes", FALSE);
  
  fw.write("<table border=\"0\" width=\"100%\">\n<tr>\n<td nowrap>");
  
  for (int i = 0; i != n; i += 1) {
    classes.elementAt(i)->write("projectFrame");
    fw.write("<br />\n");
  }
  
  fw.write("</td>\n</tr>\n</table>\n");
  end_file();

!!!128252.java!!!	generate_index() : void
  generate_index(classes, "Classes", "classes");

  int n = classes.size();
  
  start_file("classes_list", "Classes", false);
  
  fw.write("<table border=\"0\" width=\"100%\">\n<tr>\n<td nowrap>");
  
  for (int i = 0; i != n; i += 1) {
    ((UmlItem) classes.elementAt(i)).write("projectFrame");
    fw.write("<br />\n");
  }
  
  fw.write("</td>\n</tr>\n</table>\n");
  end_file();

!!!128111.cpp!!!	add_inherited_opers(inout ops : Vector) : void
  if (inherited_opers == 0) {
    const QVector<UmlItem> ch = children();
    
    inherited_opers = new Vector;
	
    for (unsigned i = 0; i != ch.size(); i += 1) {
      switch (ch[i]->kind()) {
      case aRelation:
	{
	  UmlRelation * rel = (UmlRelation *) ch[i];
	  aRelationKind k = rel->relationKind();
	  
	  if ((k == aGeneralisation) || (k == aRealization))
	    rel->roleType()->add_inherited_opers(inherited_opers);
	}
	break;
      case anOperation:
	{
	  UmlOperation * op = (UmlOperation *) ch[i];
	  
	  if ((op->visibility() == PublicVisibility) &&
	      (op->name()[0] != '~') &&
	      (op->name() != name()))
	    inherited_opers->addElement(op);
	}
      default:
	break;
      }
    }
  }

  if (ops != 0)
    for (unsigned i = 0; i != inherited_opers->size(); i += 1)
      if (! ops->contains(inherited_opers->elementAt(i)))
	ops->addElement(inherited_opers->elementAt(i));

  unload(TRUE, FALSE);
!!!128111.java!!!	add_inherited_opers(inout ops : Vector) : void
  if (inherited_opers == null) {
    UmlItem[] ch = children();
    
    inherited_opers = new Vector();
	
    for (int i = 0; i != ch.length; i += 1) {
      switch (ch[i].kind().value()) {
      case anItemKind._aRelation:
	{
	  UmlRelation rel = (UmlRelation) ch[i];
	  aRelationKind k = rel.relationKind();
	  
	  if ((k == aRelationKind.aGeneralisation) ||
	      (k == aRelationKind.aRealization))
	    rel.roleType().add_inherited_opers(inherited_opers);
	}
	break;
      case anItemKind._anOperation:
	{
	  UmlOperation op = (UmlOperation) ch[i];
	  
	  if ((op.visibility() == aVisibility.PublicVisibility) &&
	      (op.name().charAt(0) != '~') &&
	      !op.name().equals(name()))
	    inherited_opers.addElement(op);
	}
      default:
	break;
      }
    }
  }

  if (ops != null)
    for (int i = 0; i != inherited_opers.size(); i += 1)
      if (! ops.contains(inherited_opers.elementAt(i)))
	ops.addElement(inherited_opers.elementAt(i));

  unload(true, false);
!!!128627.cpp!!!	gen_cpp_decl(in s : string, in descr : bool) : void
  const char * p = (descr)
    ? (const char *) s
    : (const char *) bypass_comment(s);

  while (*p) {
    if (!strncmp(p, "${comment}", 10))
      p += 10;
    else if (!strncmp(p, "${description}", 14))
      p += 14;
    else if (!strncmp(p, "${type}", 7)) {
      p += 7;
      bool find = FALSE;

      if (baseType().type != 0) {
	UmlClass * mother = baseType().type;
	const QVector<UmlItem> ch = children();
	
	for (unsigned i = 0; i != ch.size(); i += 1) {
	  if (ch[i]->kind() == aRelation) {
	    UmlRelation * rel = (UmlRelation *) ch[i];
	    aRelationKind k = rel->relationKind();
	    
	    if (((k == aGeneralisation) ||
		 (k == aRealization)) &&
		(rel->roleType() == mother)) {
	      rel->roleType()->write();
	      generate(actuals(), mother, TRUE);
	      find = TRUE;
	      break;
	    }
	  }
	}
      }
      if (! find)
	UmlItem::write(baseType(), TRUE);
    }
    else if (!strncmp(p, "${template}", 11)) {
      p += 11;
      generate(formals());
    }
    else if (!strncmp(p, "${name}", 7)) {
      p += 7;
      writeq(name());
    }
    else if (!strncmp(p, "${inherit}", 10)) {
      p += 10;

      const QVector<UmlItem> ch = children();
      const char * sep = " : ";

      for (unsigned i = 0; i != ch.size(); i += 1) {
	if (ch[i]->kind() == aRelation) {
	  UmlRelation * rel = (UmlRelation *) ch[i];
	  aRelationKind k = rel->relationKind();
	  
	  if (((k == aGeneralisation) ||
	       (k == aRealization)) &&
	      !rel->cppDecl().isEmpty()) {
	    fw.write(sep);
	    // UmlItem::write else G++ call UmlClass::write(QCString) !
	    UmlItem::write((rel->cppVisibility() == DefaultVisibility)
		           ? rel->visibility() : rel->cppVisibility(),
			   TRUE);
	    fw.write((rel->cppVirtualInheritance()) ? " virtual " : " ");
	    rel->roleType()->write();
	    generate(actuals(), rel->roleType(), TRUE);
	    sep = ", ";
	  }
	}
      }
    }
    else if (*p == '{')
      break;
    else if (*p == '\r')
      p += 1;
    else if (*p == '\n') {
      if (descr) {
	fw.write("<br />");
	p += 1;
      }
      else {
	fw.write(' ');
	
	do
	  p += 1;
	while ((*p != 0) && (*p <= ' '));
      }
    }
    else if (*p == '@')
      manage_alias(p);
    else
      writeq(*p++);
  }

!!!128627.java!!!	gen_cpp_decl(in s : string, in descr : bool) : void
  int n = s.length();
  int index = (descr) ? 0 : bypass_comment(s);

  while (index != n) {
    if (s.startsWith("${comment}", index))
      index += 10;
    else if (s.startsWith("${description}", index))
      index += 14;
    else if (s.startsWith("${type}", index)) {
      index += 7;
      boolean find = false;

      if (baseType().type != null) {
	UmlClass mother = baseType().type;
	UmlItem[] ch = children();
	
	for (int i = 0; i != ch.length; i += 1) {
	  if (ch[i].kind() == anItemKind.aRelation) {
	    UmlRelation rel = (UmlRelation) ch[i];
	    aRelationKind k = rel.relationKind();
	    
	    if (((k == aRelationKind.aGeneralisation) ||
		 (k == aRelationKind.aRealization)) &&
		(rel.roleType() == mother)) {
	      rel.roleType().write();
	      generate(actuals(), rel.roleType(), true);
	      find = true;
	      break;
	    }
	  }
	}
      }
      if (! find)
	write(baseType(), true);
    }
    else if (s.startsWith("${template}", index)) {
      index += 11;
      generate(formals());
    }
    else if (s.startsWith("${name}", index)) {
      index += 7;
      writeq(name());
    }
    else if (s.startsWith("${inherit}", index)) {
      index += 10;

      UmlItem[] ch = children();
      String sep = " : ";

      for (int i = 0; i != ch.length; i += 1) {
	if (ch[i].kind() == anItemKind.aRelation) {
	  UmlRelation rel = (UmlRelation) ch[i];
	  aRelationKind k = rel.relationKind();
	  
	  if (((k == aRelationKind.aGeneralisation) ||
	       (k == aRelationKind.aRealization)) &&
	      (rel.cppDecl().length() != 0)) {
	    fw.write(sep);
	    write((cppVisibility() == aVisibility.DefaultVisibility)
		  ? visibility() : cppVisibility(),
		  true);
	    fw.write((rel.cppVirtualInheritance()) ? " virtual " : " ");
	    rel.roleType().write();
	    generate(actuals(), rel.roleType(), true);
	    sep = ", ";
	  }
	}
      }
    }
    else if (s.charAt(index) == '{')
      break;
    else if (s.charAt(index) == '\r')
      index += 1;
    else if (s.charAt(index) == '\n') {
      if (descr) {
	fw.write("<br />");
	index += 1;
      }
      else {
	fw.write(' ');
	
	do
	  index += 1;
	while ((index != n) && Character.isWhitespace(s.charAt(index)));
      }
    }
    else if (s.charAt(index) == '@')
      index = manage_alias(s, index);
    else
      writeq(s.charAt(index++));
  }

!!!128755.cpp!!!	gen_java_decl(in s : string) : void
  const char * p = bypass_comment(s);
  UmlRelation * extend = 0;

  while (*p != 0) {
    if (!strncmp(p, "${comment}", 10))
      p += 10;
    else if (!strncmp(p, "${description}", 14))
      p += 14;
    else if (!strncmp(p, "${public}", 9)) {
      p += 9;
      if (isJavaPublic())
	fw.write("public ");
    }
    else if (!strncmp(p, "${final}", 8)) {
      p += 8;
      if (isJavaFinal())
	fw.write("final ");
    }
    else if (!strncmp(p, "${abstract}", 11)) {
      p += 11;
      if (isAbstract())
	fw.write("abstract ");
    }
    else if (!strncmp(p, "${name}", 7)) {
      p += 7;
      writeq(name());
      generics();
    }
    else if (!strncmp(p, "${extends}", 10)) {
      p += 10;

      const QVector<UmlItem> ch = children();

      for (unsigned i = 0; i != ch.size(); i += 1) {
	if (ch[i]->kind() == aRelation) {
	  UmlRelation * rel = (UmlRelation *) ch[i];
	  aRelationKind k = rel->relationKind();
	  
	  if (((k == aGeneralisation) ||
	       (k == aRealization)) &&
	      (!rel->javaDecl().isEmpty()) &&
	      ((JavaSettings::classStereotype(stereotype()) == "interface") ||
	       (JavaSettings::classStereotype(rel->roleType()->stereotype()) != "interface"))) {
	    extend = rel;
	    fw.write(" extends ");
	    rel->roleType()->write();
	    generate(actuals(), rel->roleType(), FALSE);
	    break;
	  }
	}
      }
    }
    else if (!strncmp(p, "${implements}", 13)) {
      p += 13;

      const QVector<UmlItem> ch = children();
      const char * sep = " implements ";

      for (unsigned i = 0; i != ch.size(); i += 1) {
	if (ch[i]->kind() == aRelation) {
	  UmlRelation * rel = (UmlRelation *) ch[i];
	  aRelationKind k = rel->relationKind();
	  
	  if ((rel != extend) &&
	      ((k == aGeneralisation) ||
	       (k == aRealization)) &&
	      (!rel->javaDecl().isEmpty())) {
	    fw.write(sep);
	    sep = ", ";
	    rel->roleType()->write();
	    generate(actuals(), rel->roleType(), FALSE);
	  }
	}
      }
    }
    else if (!strncmp(p, "${@}", 4))
      p += 4;
    else if (*p == '\r')
      p += 1;
    else if (*p == '\n') {
      fw.write(' ');

      do
	p += 1;
      while ((*p != 0) && (*p <= ' '));
    }
    else if ((*p == '{') || (*p == ';'))
      break;
    else if (*p == '@')
      manage_alias(p);
    else
      writeq(*p++);
  }
!!!128755.java!!!	gen_java_decl(in s : string) : void
  int n = s.length();
  int index = bypass_comment(s);
  UmlRelation extend = null;

  while (index != n) {
    if (s.startsWith("${comment}", index))
      index += 10;
    else if (s.startsWith("${description}", index))
      index += 14;
    else if (s.startsWith("${public}", index)) {
      index += 9;
      if (isJavaPublic())
	fw.write("public ");
    }
    else if (s.startsWith("${final}", index)) {
      index += 8;
      if (isJavaFinal())
	fw.write("final ");
    }
    else if (s.startsWith("${abstract}", index)) {
      index += 11;
      if (isAbstract())
	fw.write("abstract ");
    }
    else if (s.startsWith("${name}", index)) {
      index += 7;
      writeq(name());
      generics();
    }
    else if (s.startsWith("${extends}", index)) {
      index += 10;

      UmlItem[] ch = children();

      for (int i = 0; i != ch.length; i += 1) {
	if (ch[i].kind() == anItemKind.aRelation) {
	  UmlRelation rel = (UmlRelation) ch[i];
	  aRelationKind k = rel.relationKind();
	  
	  if (((k == aRelationKind.aGeneralisation) ||
	       (k == aRelationKind.aRealization)) &&
	      (rel.javaDecl().length() != 0) &&
	      (JavaSettings.classStereotype(stereotype()).equals("interface") ||
	       !JavaSettings.classStereotype(rel.roleType().stereotype()).equals("interface"))) {
	    extend = rel;
	    fw.write(" extends ");
	    rel.roleType().write();
	    generate(actuals(), rel.roleType(), false);
	    break;
	  }
	}
      }
    }
    else if (s.startsWith("${implements}", index)) {
      index += 13;

      UmlItem[] ch = children();
      String sep = " implements ";

      for (int i = 0; i != ch.length; i += 1) {
	if (ch[i].kind() == anItemKind.aRelation) {
	  UmlRelation rel = (UmlRelation) ch[i];
	  aRelationKind k = rel.relationKind();
	  
	  if ((rel != extend) &&
	      ((k == aRelationKind.aGeneralisation) ||
	       (k == aRelationKind.aRealization)) &&
	      (rel.javaDecl().length() != 0)) {
	    fw.write(sep);
	    sep = ", ";
	    rel.roleType().write();
	    generate(actuals(), rel.roleType(), false);
	  }
	}
      }
    }
    else if (s.startsWith("${@}", index)) {
      index += 4;
    }
    else if (s.charAt(index) == '\r')
      index += 1;
    else if (s.charAt(index) == '\n') {
      fw.write(' ');

      do
	index += 1;
      while ((index != n) && Character.isWhitespace(s.charAt(index)));
    }
    else if ((s.charAt(index) == '{') || (s.charAt(index) == ';'))
      break;
    else if (s.charAt(index) == '@')
      index = manage_alias(s, index);
    else
      writeq(s.charAt(index++));
  }
!!!128321.cpp!!!	generate(in a : UmlActualParameter, in mother : UmlClass, in cpp : bool) : void
  unsigned i;
  unsigned n = a.count();
  
  // search first actual of mother
  for (i = 0; ; i += 1) {
    if (i == n)
      return;
    if (a[i].superClass() == mother)
      break;
  }
    
  const char * sep = "<";
  
  do {
    writeq(sep);
    UmlItem::write(a[i].value(), cpp);
    sep = ", ";
  }
  while ((++i != n) && (a[i].superClass() == mother));

  writeq('>');
!!!128321.java!!!	generate(in a : UmlActualParameter, in mother : UmlClass, in cpp : bool) : void
  int i;
  
  // search first actual of mother
  for (i = 0; ; i += 1) {
    if (i == a.length)
      return;
    if (a[i].superClass() == mother)
      break;
  }
    
  String sep = "<";
  
  do {
    writeq(sep);
    write(a[i].value(), cpp);
    sep = ", ";
  }
  while ((++i != a.length) && (a[i].superClass() == mother));

  writeq('>');
!!!128449.cpp!!!	generate(in f : UmlFormalParameter) : void
  unsigned n = f.count();
  
  if (n != 0) {
    const char * sep = "template<";
    unsigned i;
    
    for (i = 0; i != n; i += 1) {
      writeq(sep);
      writeq(f[i].type());
      fw.write(' ');
      writeq(f[i].name());
      sep = ", ";
    }
    
    writeq("> ");
  }
  else if (name().find("<") != -1)
    writeq("template<> ");
!!!128449.java!!!	generate(in f : UmlFormalParameter) : void
  if (f.length != 0) {
    String sep = "template<";
    int i;
    
    for (i = 0; i != f.length; i += 1) {
      writeq(sep);
      writeq(f[i].type());
      fw.write(' ');
      writeq(f[i].name());
      sep = ", ";
    }
    
    writeq("> ");
  }
  else if (name().indexOf("<") != -1)
    fw.write("template<> ");
!!!148226.cpp!!!	generics() : void
  QValueList<UmlFormalParameter> f = formals();
  unsigned n = f.count();
  
  if (n != 0) {
    const char * sep = "<";
    unsigned i;
    
    for (i = 0; i != n; i += 1) {
      writeq(sep);
      sep = ", ";
      writeq(f[i].name());
      
      const UmlTypeSpec & t = f[i].extend();
      
      if ((t.type != 0) || ! t.explicit_type.isEmpty()) {
	fw.write(" extends ");
	UmlItem::write(t, FALSE);
      }
    }
    
    writeq('>');
  }
!!!148226.java!!!	generics() : void
  UmlFormalParameter[] f = formals();
  
  if (f.length != 0) {
    String sep = "<";
    int i;
    
    for (i = 0; i != f.length; i += 1) {
      writeq(sep);
      sep = ", ";
      writeq(f[i].name());
      
      UmlTypeSpec t = f[i].extend();
      
      if ((t.type != null) || (t.explicit_type.length() != 0)) {
	fw.write(" extends ");
	UmlItem.write(t, false);
      }
    }
    
    writeq('>');
  }
!!!130803.cpp!!!	generate() : void
  if (! flat) {
    int n = classes.size();
    
    for (int i = 0; i != n; i += 1)
      ((UmlClass *) classes.elementAt(i))->html();
  }
!!!130803.java!!!	generate() : void
  if (! flat) {
    int n = classes.size();
    
    for (int i = 0; i != n; i += 1)
      ((UmlClass) classes.elementAt(i)).html();
  }
!!!148866.cpp!!!	chapterp() : bool
  return flat;
!!!148866.java!!!	chapterp() : bool
  return flat;
